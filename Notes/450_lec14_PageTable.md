# Virtual Memory with Paging
## Preview
- Page Table with Hardware Support
    - Translation Look-Aside Buffer
- Page Table Structure
    - Shared Pages
    - Multi-level Page Table
    - Hashed Page Table
    - Inverted Page Table  

## Page Table with Hardware Support* 
- OS maintains a page table per process. Pointer to page table stored in process table (process control block).
- When short term scheduler selects a process it loads its page table into Memory.  

Hardware Implementation of Page Table can be done in 2 ways:
- Implemented as a set of **dedicated high-speed hardware registers**
    - This makes page-address translation very efficient, but **increases *context-switch-time***. This is because each register must be exchanged during a context switch so it can only be applied with **small** page tables. 
- **Page-Table Based Register** 
    - Used to save a pointer to a page table which is kept in main memory. Changing the page table only changes the contents of this register.  

### Translation Look-Aside Buffer 
> Maintaining page table in memory can result in slower memory access times  

In order to access an instruction located in a virtual address i, system needs two memory access time.  
1. Access memory to get page frame number from page table in the memory.  
2. Calculate physical address by combining page frame number + offset.  

This causes memory access to be slowed by a factor of 2. This is considered intolerable in most circumstances.  

The standard solution to this is:  
Use a special, small, fast-lookup **hardware cache** called a **translation look-aside buffer** (TLB).  

In **TLB** each entry consists of two parts:
1. **Key (or tag)**
2. **Value**  

The TLB is used with page table via **saving a few of page tables entries**.  

### Translation Look-Aside Buffer cont.  
As mentioned, **TLB** only saves a few entries from the page table.  

When a logical address is generated by the **CPU**, the **MMU** first checks if its **page number** is present in the **TLB**.  
- If found: Frame number is immediately available (hit) and MMU can map physical address memory.  
- If **not** found (**TLB MISS**): The address translation proceeds as follows:
    - Search page table and get a page frame number to map physical address.
    - Search result added to TLB so next time it needs to be used it will be faster to access.
    - If TLB is full, an existing entry must be selected for replacement based on **replacement policies**:
        - **Least Recently Used (LRU)**:
        - **Round-Robin**
        - **Random**

### Translation Look-Aside Buffer (TLB) cont.  
**Hit Ratio**: Percentage of times that the page number of interest is found in the TLB.  

>An 80% **hit ratio** means that we find teh desired page number in the **TLB** 80% of the time.  

If it takes **10 nanoseconds** to access memory, then a mapped-memory access takes **10 nanoseconds** with a **hit**.  

If the **TLB** search for desired pages results in a **miss**, then need **two memory accesses**:  
- Access memory to get page table frame number (10 nanoseconds)
- Access desired byte in memory (10 nanoseconds) . 

>Effective access time with an **80% hit** ratio = **0.8 * 10 + 0.2 * 20 = 12 nanoseconds**.  

### Translation Look-Aside Buffer (TLB) cont.  
CPUs today often provide **multiple levels** of **TLBs** . 
> Intel Core i7 CPU has a **128-entry L1 instruction TLB** and a **64-entry L1 data TLB**.  

In event of a **Miss** as **L1**, it takes the CPU 6 cycles to check for the entry in the **L2 512-entry TLB**.  

A **miss** in **L2** means that the CPU must either *walk through* the **page-table** entries in memory to find the associated **frame address**, which can take *hundred* of cycles, or *interrupt* the OS to have it do the work.  

## Shared Pages 
**Advantage of paging**: Possibility of sharing **common code**. 
- This is particularly important in an environment with multiple processes.  

* Standard C library provides a portion of system call interface for many versions of UNIX (Linux).  
* On a typical Linux system, most user processes require standard C library code (libc).
    - If code in a library is **re-entrant code**: can be shared by multiple processes. Instead of each process loading its own copy of libc into its address space, one copy can be shared by multiple processes.
        - **Re-entrant code** is non-self-modifying code: it never changes during execution.
    - Heavily used programs can also be shared:
        - Compilers
        - Window systems
        - Database systems
        - etc

## Multi-Level Page Table 
Basic Idea: **Avoid keeping all the page tables in memory all the time!** 

Ex: A system is using second level page tables.
- System generates **32 bit virtual address** with page size **4KB**
- This gives us **32 virtual addresses** that are partitioned into **10-bit PT1 field** and **10-bit PT2 field** and a **12-bit offset field (for page size 4KB)**.  
- Since offset are **12 bits**, pages are **4KB** and there are a total `2^20` of them.

| PT1  | PT2  | Offset |
|------|------|--------|
| 10 bits | 10 bits  | 12 bits | 

**First level page table** is the **page table for page table**.
- First level page has `2^10` entries.
- Present/absent bit is used int he first level page entries used to save whether a page table is in memory or not. 

**Second level page tables are page tables for pages**
- Each second level page has `2^10` entries, and a page size of `4KB`, each second level page supports `2^10 * 4KB = 4MB` of virtual space.
- There are $2^{10}$ second level page table, this example system support `4MB * 2^10 = 4GB` of virtual memory.


